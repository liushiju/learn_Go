# 10 | Context：必须掌握的多线程并发控制神器

## sync.Map方法

1. **Store**：存储一对key-value值
2. **Load**：根据key获取对应的value值，并且可以判断key是否存在
3. **LoadOrStore**：如果 key 对应的 value 存在，则返回该 value；如果不存在，存储相应的 value
4. **Delete**：删除一个 key-value 键值对
5. **Range**：循环迭代 sync.Map，效果与 for range 一样

```go
package main

import (
	"fmt"
	"sync")


func main() {
	var person sync.Map
	// 将键值对保存在sync.Map
	person.Store("张三", 26)
	person.Store("李四", 30)
	person.Store("王五", 32)
	person.Store("赵六", 37)
	// 从sync.Map中根据键取值
	fmt.Println(person.Load("张三"))
	// 根据键删除对应的键值对
	person.Delete("张三")
	// 遍历所有的sync.Map中的键值对
	person.Range(func(key, value interface{}) bool {
		fmt.Println("iterate: ", key,value)
		return true
	})

}
```

## 协程如何退出

一个协程启动后，大部分情况需要等待里面的代码执行完毕，然后协程会自行退出。但是如果有一种情景，需要让协程提前退出怎么办呢？

```go
package main

import (
	"fmt"
	"sync"
	"time"
)

func main() {
	var wg sync.WaitGroup
	wg.Add(1)
	go func() {
		defer wg.Done()
		watchDog("【监控狗1】")
	}()
	wg.Wait()
}

func watchDog(name string) {
	// 开启for select循环，一直后台监控
	for {
		select {
		default:
			fmt.Println(name, "正在监控... ...")
		}
		time.Sleep(1 * time.Second)
	}
}
```

通过 watchDog 函数实现了一个监控狗，它会一直在后台运行，每隔一秒就会打印"监控狗正在监控……"的文字。

如果需要让监控狗停止监控、退出程序，一个办法是定义一个全局变量，其他地方可以通过修改这个变量发出停止监控狗的通知。然后在协程中先检查这个变量，如果发现被通知关闭就停止监控，退出当前协程。

但是这种方法需要通过加锁来保证多协程下并发的安全，基于这个思路，有个升级版的方案：用 select+channel 做检测

```go
package main

import (
	"fmt"
	"sync"
	"time"
)

func main() {
	var wg sync.WaitGroup
	wg.Add(1)
	// 用来停止监控狗
	stopCh := make(chan bool)
	go func() {
		defer wg.Done()
		watchDog(stopCh, "【监控狗1】")
	}()
	// 想让监控狗监控5秒
	time.Sleep(5 * time.Second)
	// 发出停止指令
	stopCh <- true
	wg.Wait()
}

func watchDog(stopCh chan bool,name string) {
	// 开启for select循环，一直后台监控
	for {
		select {
		case <- stopCh:
			fmt.Println(name, "停止指令已收到，马上停止")
			return
		default:
			fmt.Println(name, "正在监控... ...")
		}
		time.Sleep(1 * time.Second)
	}
}
```

这个示例是使用 select+channel 的方式改造的 watchDog 函数，实现了通过 channel 发送指令让监控狗停止，进而达到协程退出的目的。

1. 为 watchDog 函数增加 stopCh 参数，用于接收停止指令
2. 在 main 函数中，声明用于停止的 stopCh，传递给 watchDog 函数，然后通过 stopCh<-true 发送停止指令让协程退出

## Context

通过 select+channel 让协程退出的方式比较优雅，但是如果我们希望做到同时取消很多个协程呢？如果是定时取消协程又该怎么办？这时候 select+channel 的局限性就凸现出来了，即使定义了多个 channel 解决问题，代码逻辑也会非常复杂、难以维护。

要解决这种复杂的协程问题，必须有一种可以跟踪协程的方案，只有跟踪到每个协程，才能更好地控制它们，这种方案就是 Go 语言标准库为我们提供的 Context，也是这节课的主角。

```go
package main

import (
	"context"
	"fmt"
	"sync"
	"time"
)

func main() {
	var wg sync.WaitGroup
	wg.Add(1)
	ctx, stop := context.WithCancel(context.Background())
	go func() {
		defer wg.Done()
		watchDog(ctx, "【监控狗1】")
	}()
	// 先让监控狗监控5秒
	time.Sleep(5 * time.Second)
	// 发停止指令
	stop()
	wg.Wait()
}

func watchDog(ctx context.Context, name string) {
	// 开启for select循环，一直后台监控
	for {
		select {
		case <-ctx.Done():
			fmt.Println(name, "停止指令已收到，马上停止")
			return
		default:
			fmt.Println(name, "正在监控... ...")
		}
		time.Sleep(1 * time.Second)
	}
}
```

#### 相比于 select + channel的方案，Context方案有4点改动：

1. watchDog 的 stopCh 参数换成了 ctx，类型为 context.Context
2. 原来的 case <-stopCh 改为 case <-ctx.Done()，用于判断是否停止
3. 使用 context.WithCancel(context.Background()) 函数生成一个可以取消的 Context，用于发送停止指令。这里的 context.Background() 用于生成一个空 Context，一般作为整个 Context 树的根节点
4. 原来的 stopCh <- true 停止指令，改为 context.WithCancel 函数返回的取消函数 stop()。

可以看到，这和修改前的整体代码结构一样，只不过

#### 什么是Context

一个任务会有很多个协程协作完成，一次 HTTP 请求也会触发很多个协程的启动，而这些协程有可能会启动更多的子协程，并且无法预知有多少层协程、每一层有多少个协程

如果因为某些原因导致任务终止了，HTTP 请求取消了，那么它们启动的协程怎么办？该如何取消呢？因为取消这些协程可以节约内存，提升性能，同时避免不可预料的 Bug。

Context 就是用来简化解决这些问题的，并且是并发安全的。<font color=red>Context 是一个接口，它具备手动、定时、超时发出取消信号、传值等功能，主要用于控制多个协程之间的协作，尤其是取消操作。</font>一旦取消指令下达，那么被 Context 跟踪的这些协程都会收到取消信号，就可以做清理和退出操作。

Context 接口只有四个方法，下面进行详细介绍，在开发中你会经常使用它们，你可以结合下面的代码来看。

Context 接口只有四个方法，下面进行详细介绍，在开发中你会经常使用它们，你可以结合下面的代码来看。

