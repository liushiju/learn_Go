# 07 | 错误处理：如何通过 error、deferred、panic 等处理错误？

## 思考题

人既会走也会跑

``` go
type WalkRun interface {
    Walk()
    Run()
}
```

现在就可以让结构体 person 实现这个接口了

``` go
func (p *person) Walk() {
    fmt.Printf("%s能走\n", p.name)
}
func (p *person) Run(){
   fmt.Printf("%s能跑\n",p.name)
}
```

## error接口

在Go语言中，错误是通过内置的error接口表示的。

```go
type error interface {
    Error() string
}
```

> ch07/main.go

```go
package main

import (
	"fmt"
	"strconv"
)

func main() {
	i, err := strconv.Atoi("a")
	if err != nil {
		fmt.Println(err)
	} else {
		fmt.Println(i)
	}
}
```

> 结果：
>
> strconv.Atoi: parsing "a": invalid syntax

这个错误信息就是通过接口error返回

```go
func Atoi(s string)(int, error)
```

一般而言，error接口用于方法或者函数执行遇到错误时进行返回，而且是第二个返回值

## error工厂函数

除了可以使用其他函数，自定义的函数也可以返回错误信息给调用者

```go
func add(a,b int) (int,error){
   if a<0 || b<0 {
      return 0,errors.New("a或者b不能为负数")
   }else {
      return a+b,nil
   }
}
```

add 函数会在 a 或者 b 任何一个为负数的情况下，返回一个错误信息，如果 a、b 都不为负数，错误信息部分会返回 nil，这也是常见的做法。所以调用者可以通过错误信息是否为 nil 进行判断。

```go
sum,err := add(-1,2)
if err!=nil{
    fmt.Println(err)
}else{
    fmt.Println(sum)
}
```

## 自定义 error

上面采用工厂返回错误信息的方式只能传递一个字符串，也就是携带的信息只有字符串，如果想要携带更多信息这个时候就需要自定义 error 。

自定义 error 其实就是先自定义一个新类型，比如结构体，然后让这个类型实现 error 接口

```go
package main

type commonError struct {
	errorCode int
	errorMsg  string
}

func (ce *commonError) Error() string {
	return 0, &commonError{
		errorCode: 1,
		errorMsg:  "a 或 b不能为负数"}
}
```

通过字面量的方式创建一个 *commonError 返回，其中 errorCode 值为 1，errorMsg 值为 “a 或者 b 不能为负数”。

## error断言

有了自定义的 error，并且携带了更多的错误信息后，就可以使用这些信息了。你需要先把返回的 error 接口转换为自定义的错误类型，用到的知识是上节课的类型断言。

下面代码中的 err.(*commonError) 就是类型断言在 error 接口上的应用，也可以称为 error 断言。

